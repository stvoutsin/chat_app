from passlib.context import CryptContext
import openai
from .config import OPENAI_CONFIG
from .config import OPENAI_API_KEY

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
openai.api_key = OPENAI_API_KEY

def hash_password(password: str) -> str:
    """
    Hashes the given password using bcrypt.

    Parameters:
        password: The password to be hashed.

    Returns:
        str: The hashed password.
    """
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifies the given plain password against the hashed password.

    Parameters:
        plain_password: The plain password to be verified.
        hashed_password: The hashed password to be compared against.

    Returns:
        bool: True if the plain password matches the hashed password, False otherwise.
    """
    return pwd_context.verify(plain_password, hashed_password)

def ai_rewrite_message(message: str, tone: str = "nice") -> str:
    """
    Rewrites the given message using the GPT-3 model.

    Parameters:
        message: The message to be rewritten.
        tone: The desired tone for the rewritten message (default: "nice").

    Returns:
        str: The rewritten message generated by the GPT-3 model.
    """
    # Generate text using the GPT-3 model
    response = openai.Completion.create(
        engine="text-davinci-002",
        prompt=f"Can you return the following message, in a more {tone} tone: {message}",
        temperature=OPENAI_CONFIG["temperature"],
        max_tokens=OPENAI_CONFIG["max_tokens"],
        top_p=OPENAI_CONFIG["top_p"],
        frequency_penalty=OPENAI_CONFIG["frequency_penalty"],
        presence_penalty=OPENAI_CONFIG["presence_penalty"]
    )
    return response.choices[0].text
